# -*- coding: utf-8 -*-
"""BinarySearchTree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1szEy9QETusIfafcXna6_nEuzCUTux6q-
"""

class Node:
  
  def __init__(self, key):
    self.key = key
    self.left = None
    self.right = None
    
  def set_left(self, left):
    self.left = left
    
  def set_right(self, right):
    self.right = right
    
  def get_left(self):
    return self.left
  
  def get_right(self):
    return self.right
  
  def get_key(self):
    return self.key
  
class Binary_search_tree:
  
  def __init__(self):
    self.root = None
    
  
  def get_root(self):
    return self.root
  
  def search(self, key):
    return self.check(self.root, key)
  
  def check(self, node, key):
    if node is None:
      return None
    
    if node.get_key() == key:
      return node
    elif node.get_key() > key:
      return self.check(node.get_left(), key)
    else:
      return self.check(node.get_right(), key)
  
  def insert(self,node):
    if self.root is None:
      self.root = node
    else:
      self.insert_node(self.root, node)

  def insert_node(self,parent,node):
    if parent.get_key() == node.get_key():
      pass
    else:
      if parent.get_key() > node.get_key():
        left = parent.get_left()
        if left is None:
          parent.set_left(node)
        else:
          self.insert_node(left,node)
      else:
        right = parent.get_right()
        if right is None:
          parent.set_right(node)
        else:
          self.insert_node(right,node)
  
  def print_tree(self):
    self.print_node(self.root,0)
  
  def print_node(self, node,depth):
    if node is not None:
      block = ""
      for i in range(0,depth):
        block += "  "
    
      print(block , node.get_key())
      self.print_node(node.get_left(),depth+1)
      self.print_node(node.get_right(),depth+1)
  


  def delete_node(self,key):
    parent = self.parent_search(self.root,key)
    print(parent.get_key())
    return self.delete(self.root,key,parent)
  
  
  
  
  def in_order(self,node,key): # inorder_node 찾기 
    if node.get_left() is None:
      inorder_node = node
      return inorder_node
    else:
      return self.in_order(node.get_left(),key)
      #inorder_node = node
      
      #print(node.get_key() ,end = " ")
      
      
     

  def parent_search(self,node,key):
    if node.get_key() == key:
      return node
    
    if node.get_left() is None:
      pass 
    elif node.get_right() is None:
      pass
    elif node.get_left().get_key() == key:
      return node
    
    elif node.get_right().get_key() == key:
      return node
    elif node.get_key() > key:
      return self.parent_search(node.get_left(),key)
    else:
      return self.parent_search(node.get_right(),key)
    
      
  #삭제노드에서 자식노드가 없을 떄
  def noneNode(self,node,parent, key):
    
    if parent.get_key() < key:
      none_node = node.get_right()
      node = parent.set_right(none_node)
      return node
    else:
      none_node = node.get_left()
      node = parent.set_left(none_node)
      return node
  
  #삭제노드에서 자식노드가 한개 있을떄
  def oneNode(self,node,parent,key):
    if node.get_right() is not None:
      node = node.get_right()
      node = parent.set_right(node)
      return node
    else:
      node = node.get_left()
      node = parent.set_left(node)  
      return node
  
  def twoNode(self,node,parent,key):
    inorder_node = self.in_order(node.get_right(),key)
    None_node = inorder_node.get_left()
    left = node.get_left()
    right = node.get_right()
    if right.get_left() is not None:
      right.set_left(None_node)
    inorder_node.set_left(left)
    if right.get_key() == inorder_node.get_key():
      pass
      
    else:
      inorder_node.set_right(right)
    
    if key < parent.get_key():
      node = parent.set_left(inorder_node)
      return node
    else:
      node = parent.set_right(inorder_node)
      return node
    
  # 노드 삭제 메소드
  def delete(self,node,key,parent):
    if node.get_key() == key:

      if node.get_left()is not None and node.get_right() is not None :
        print("2개입니다")
        return self.twoNode(node,parent,key)
      elif node.get_left() is not None or node.get_right() is not None:
        print("한개입니다")
        return self.oneNode(node,parent,key)
      else:
        print("없습니다")
        return self.noneNode(node,parent,key)
    elif node.get_key() > key:
      return self.delete(node.get_left(),key,parent)
    else:
      return self.delete(node.get_right(),key,parent)
    
    
bst = Binary_search_tree()

node_40 = Node(40)
bst.insert(node_40)
node_15 = Node(15)
bst.insert(node_15)
node_69 = Node(69)
bst.insert(node_69)
node_8 = Node(8)
bst.insert(node_8)
node_25 = Node(25)
bst.insert(node_25)
node_54 = Node(54)
bst.insert(node_54)
node_86 = Node(86)
bst.insert(node_86)
node_5 = Node(5)
bst.insert(node_5)
node_10 = Node(10)
bst.insert(node_10)
node_20 = Node(20)
bst.insert(node_20)
node_30 = Node(30)
bst.insert(node_30)
node_50 = Node(50)
bst.insert(node_50)
node_66 = Node(66)
bst.insert(node_66)
node_83 = Node(83)
bst.insert(node_83)
node_90 = Node(90)
bst.insert(node_90)
node_35 = Node(35)
bst.insert(node_35)

#bst.start_in_order(69)
bst.delete_node(15)
bst.delete_node(5)
bst.delete_node(8)
bst.print_tree()
#bst.delete_node(10)
#bst.delete_node(30)
#bst.print_tree()
#bst.delete_node(30)


